import { useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/contexts/AuthContext';

interface CreateOrderData {
  customerName: string;
  customerEmail: string;
  customerPhone: string;
  shippingAddress: {
    street_address: string;
    city: string;
    state: string;
    postal_code: string;
    country: string;
  };
  items: {
    productId: string;
    productName: string;
    productImage: string | null;
    quantity: number;
    unitPrice: number;
  }[];
  subtotal: number;
  shippingCost: number;
  tax: number;
  total: number;
  notes?: string;
}

export const useCreateOrder = () => {
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const { user } = useAuth();

  return useMutation({
    mutationFn: async (orderData: CreateOrderData) => {
      // Check stock availability for all items
      for (const item of orderData.items) {
        const { data: product } = await supabase
          .from('products')
          .select('stock_quantity, is_made_to_order, name')
          .eq('id', item.productId)
          .single();
        
        if (product && !product.is_made_to_order && product.stock_quantity < item.quantity) {
          throw new Error(`Sorry, "${product.name}" only has ${product.stock_quantity} items in stock.`);
        }
      }

      // Create order - order_number is generated by trigger
      const { data: order, error: orderError } = await supabase
        .from('orders')
        .insert({
          user_id: user?.id,
          customer_name: orderData.customerName,
          customer_email: orderData.customerEmail,
          customer_phone: orderData.customerPhone,
          shipping_address: orderData.shippingAddress as unknown as import('@/integrations/supabase/types').Json,
          billing_address: orderData.shippingAddress as unknown as import('@/integrations/supabase/types').Json,
          subtotal: orderData.subtotal,
          shipping_cost: orderData.shippingCost,
          tax: orderData.tax,
          total: orderData.total,
          notes: orderData.notes,
          status: 'pending',
          order_number: '', // Will be generated by trigger
        })
        .select()
        .single();

      if (orderError) throw orderError;

      // Create order items
      const orderItems = orderData.items.map(item => ({
        order_id: order.id,
        product_id: item.productId,
        product_name: item.productName,
        product_image: item.productImage,
        quantity: item.quantity,
        unit_price: item.unitPrice,
        total_price: item.unitPrice * item.quantity,
      }));

      const { error: itemsError } = await supabase
        .from('order_items')
        .insert(orderItems);

      if (itemsError) throw itemsError;

      // Decrement stock for each product
      for (const item of orderData.items) {
        const { data: product } = await supabase
          .from('products')
          .select('stock_quantity, low_stock_threshold')
          .eq('id', item.productId)
          .single();
        
        if (product) {
          const newStock = Math.max(0, product.stock_quantity - item.quantity);
          await supabase
            .from('products')
            .update({ stock_quantity: newStock })
            .eq('id', item.productId);
          
          // Send admin alert if stock hits 0 or low threshold
          if (newStock === 0 || (product.low_stock_threshold && newStock <= product.low_stock_threshold)) {
            try {
              await supabase.functions.invoke('send-order-notification', {
                body: {
                  type: 'admin_alert',
                  product: {
                    id: item.productId,
                    name: item.productName,
                    stock_quantity: newStock,
                  },
                },
              });
            } catch (e) {
              console.error('Failed to send low stock alert:', e);
            }
          }
        }
      }

      // Send order confirmation emails via Resend
      try {
        await supabase.functions.invoke('send-order-notification', {
          body: {
            type: 'order_created',
            order: {
              order_number: order.order_number,
              customer_name: orderData.customerName,
              customer_email: orderData.customerEmail,
              customer_phone: orderData.customerPhone,
              items: orderData.items.map(item => ({
                product_name: item.productName,
                quantity: item.quantity,
                unit_price: item.unitPrice,
                total_price: item.unitPrice * item.quantity,
              })),
              subtotal: orderData.subtotal,
              shipping_cost: orderData.shippingCost,
              tax: orderData.tax,
              total: orderData.total,
              shipping_address: orderData.shippingAddress,
            },
          },
        });
        console.log('Order confirmation emails sent successfully');
      } catch (notificationError) {
        console.error('Failed to send order notification:', notificationError);
        // Don't throw - order was created successfully
      }

      // Send invoice email
      try {
        await supabase.functions.invoke('send-invoice', {
          body: {
            orderNumber: order.order_number,
            customerName: orderData.customerName,
            customerEmail: orderData.customerEmail,
            customerPhone: orderData.customerPhone,
            shippingAddress: orderData.shippingAddress,
            items: orderData.items.map(item => ({
              name: item.productName,
              quantity: item.quantity,
              unitPrice: item.unitPrice,
              totalPrice: item.unitPrice * item.quantity,
            })),
            subtotal: orderData.subtotal,
            shippingCost: orderData.shippingCost,
            tax: orderData.tax,
            total: orderData.total,
            createdAt: order.created_at,
          },
        });
        console.log('Invoice email sent successfully');
      } catch (invoiceError) {
        console.error('Failed to send invoice:', invoiceError);
        // Don't throw - order was created successfully
      }

      return order;
    },
    onSuccess: (order) => {
      queryClient.invalidateQueries({ queryKey: ['orders'] });
      queryClient.invalidateQueries({ queryKey: ['products'] });
      toast({ 
        title: 'Order placed!', 
        description: `Your order ${order.order_number} has been placed successfully.` 
      });
    },
    onError: (error: Error) => {
      toast({ title: 'Error', description: error.message, variant: 'destructive' });
    },
  });
};
